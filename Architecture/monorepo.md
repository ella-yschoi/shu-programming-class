# 📒 모노레포

모노레포란, 버전 관리 시스템에서 두 개 이상의 프로젝트 코드가 동일한 저장소에 저장되는 소프트웨어 개발 전략입니다.

<br/>

## 0. 목차

<!-- no toc -->
1. [모노레포의 등장 배경](#1-모노레포의-등장-배경)
2. [모노레포의 탄생](#2-모노레포의-탄생)
3. [모노레포의 오해](#3-모노레포의-오해)
4. [참고 자료](#4-참고-자료)

<br/>

## 1. 모노레포의 등장 배경

### (1) 모놀리식에 대한 비판

모노레포 개발 전략은 고전적 소프트웨어 개발 방식인 모놀리식 애플리케이션(monolithic application)의 한계에 대한 비판에서 출발합니다. 여기서 모놀리식 애플리케이션이란, 소프트웨어 엔지니어링에서 모듈화 없이 설계된 소프트웨어 애플리케이션을 말합니다.

소스 코드가 모듈화 없이 하나의 프로젝트로 구성된다면, 코드가 서로 직접적으로 의존하며 단 하나의 버전으로 관리되면서 관심 분리(separation of concerns)가 어려워지고, 설계, 리팩토링, 배포 등의 작업을 매번 거대한 단위로 처리해야 하므로 개발상 많은 제약과 비효율이 있을 것입니다.

### (2) 모듈화

이러한 모놀리식 구조의 한계는 모듈화, 즉 모듈식 프로그래밍을 통해 해결할 수 있습니다. 그리고 이렇게 만든 모듈이 다른 애플리케이션에도 사용될 수 있다면 이 소스를 어디에 위치시켜야 할까요? 이때, 해당 모듈을 위한 독자적인 저장소가 있다면 관리하기 쉬울 것입니다. 이 구조를 바로 '멀티레포' 라고 합니다.

### (3) 멀티레포

멀티레포는 폴리레포(polyrepo) 구조라고도 부르며, 분리된 각 모듈은 멀티레포 구조에서 고유한 저장소가 있는 독자적인 프로젝트가 됩니다. 현재 대부분의 애플리케이션을 개발하는 표준적인 방법이며, 팀의 자율성이라는 큰 이유로 인해 이 방식을 선호합니다.

### (4) 멀티레포의 단점

하지만 양날의 검처럼 이 자율성은 '고립'에 의해 제공되고, 이 고립은 협업을 방해할 수 있습니다. 예를 들어, 새로운 공유 패키지를 생성할 때마다 개발 환경 구축 및 빌드, 퍼블리시의 과정을 거쳐야 하며, 패키지간의 중복 코드가 있을 수 있습니다. 이는 관리해야 할 포인트가 증가할 수 있습니다. 또한 개발자 경험(DX)이 일관성이 없을 수 있어 정신적 오버헤드를 만들기도 합니다.

### (5) 멀티레포의 단점 보완

이에 모듈을 적절히 분리하여 관심사 분리를 이루면서도, 동시에 분리된 모듈을 쉽게 참조하고 테스트/빌드/배포 과정도 한번에 할 수 있는 '모노레포'가 탄생합니다.

<br/>

## 2. 모노레포의 탄생

### (1) 모노레포의 특징

모노레포(monorepo) 구조는 두 개 이상의 프로젝트가 동일한 저장소에 저장되는 소프트웨어 개발 전략입니다. 분리된 모듈들은 모노레포에서 여전히 독자 프로젝트로 존재하지만 저장소는 같은 곳을 사용합니다.

모노레포의 또 다른 중요한 특징 중 하나는 프로젝트 간의 관계입니다. 단순히 여러 프로젝트가 하나의 저장소를 사용한다고 해서 모노레포 구조라고 부르기에는 부족합니다. 흔히 모노레포에서는 프로젝트 사이에 의존성이 존재하거나 같은 제품군이거나 하는 정의된 관계가 존재합니다.

### (2) 모노레포가 해결하는 멀티레포의 문제

모노레포는 프로젝트 생성을 더 쉽게 해주며, 의존성 관리 또한 쉽게 해줍니다. 멀티레포와는 다르게 관리 포인트와 개발자 경험이 일관됩니다. 더불어, 서로 의존하는 저장소들의 리팩토링 비용이 감소됩니다. 예를 들어, 100개의 라이브러리로 만든 10개의 앱을 리팩토링하고 변경사항을 커밋하기 전, 작동 여부를 모두 확인할 수 있습니다.

더불어, 모노레포 사용 전에는 공용 모듈에 무언가 변경 사항이 생기면 모든 컴포넌트에 수정 PR을 올려야 했었으나, 모노레포를 도입한다면 하나의 repo이니 PR 또한 한번에 올릴 수 있다는 장점이 있습니다.

그리고 배포 github action의 `.yml` 파일에 특정 모듈의 검증 로직을 넣으면 변경 사항이 생겼을 때, 해당 모듈을 참조한다고 정의해놓은 컴포넌트들의 테스트를 돌립니다. 그래서 CI 단계에서 해당 모듈을 사용하는 컴포넌트에서 변경사항을 감지하고 누락되지 않도록 하는 장치를 마련할 수 있기도 합니다.

이 밖에도 테스트 및 빌드 범위를 최소화할 수 있습니다. 소스 변경 시 모든 프로젝트를 다시 빌드하거나 다시 테스트하지 않으며, 대신 변경 사항의 영향을 받는 프로젝트만 다시 테스트하고 빌드합니다.

<br/>

## 3. 모노레포의 오해

### (1) 다른 팀이 내가 모르는 사이에 내 코드를 변경한다면?

다행히 GitHub에는 [CODEOWNERS](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners)와 같은 기능을 사용하여 폴더 기반으로 소유권을 구성할 수 있습니다.

### (2) 모노레포가 멀티레포보다 항상 나은 방법인가?

그렇지 않습니다. 각자 장단점이 교차하기 때문에 적절한 상황에서 사용해야 합니다. 모노레포의 핵심적 특징은 프로젝트 사이의 관계이고, 모노레포가 적절한 상황은 다음과 같습니다.

- 유사한 제품의 집합
- 여러 프로젝트의 변화를 한눈에 파악해야 할 때
- 호스트 애플리케이션을 플러그인 등으로 확장할 때
- 공통 기능을 재사용하는 관련된 프로젝트의 집합
- 유사한 DevOps로 구성된 프로젝트의 집합

<br/>

## 4. 참고 자료

- [Monorepo.tools](https://monorepo.tools/#monorepo-features)
- [NAVER D2 - 모던 프론트엔드 프로젝트 구성 기법 - 모노레포 개념 편](https://d2.naver.com/helloworld/0923884)
- [MUSINSA Tech - 모노레포 이렇게 좋은데 왜 안써요?](https://medium.com/musinsa-tech/journey-of-a-frontend-monorepo-8f5480b80661)
