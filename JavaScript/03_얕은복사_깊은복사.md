# 📒 얕은 복사와 깊은 복사

## 0. 목차

1. [얕은 복사](#1-얕은-복사)
2. [깊은 복사](#2-깊은-복사)

<br/>

## 1. 얕은 복사

### (1) 설명

아래 코드에서 `home` 객체는 얕은 복사(shallow copy)가 된다. 여기서 얕은 복사란, 객체의 최상위 수준의 값만 복사하는 것을 의미한다.

```javascript
const ella = {name: 'Ella', age: 20};
const updated = {
  ...ella,
  job: 'FE developer',
  home: {address: 'seoul'}
};

console.log(updated); // {name: 'Ella', age: 20, job: 'FE developer'}
```

### (2) 부작용

위 코드에서 `updated` 객체는 `ella` 객체의 속성들을 복사받는다. `...ella` 구문은 `ella` 객체의 모든 상위 수준의 속성들을 `updated` 객체로 복사하는데, 이때 `name`과 `age`는 간단한 값이므로 문제가 없지만, `home` 속성은 객체다.

`home` 객체가 얕은 복사되었다는 것은, `updated` 객체의 `home` 속성과 원본 `ella` 객체의 `home` 속성이 동일한 메모리 주소를 참조한다는 의미다. 즉, 아래와 같이 `updated.home` 또는 `ella.home` 중 하나를 변경하면, 두 객체 모두에 영향을 미치게 된다. 이는 얕은 복사의 주요 특징 중 하나이며, 때로는 예기치 않은 부작용을 초래할 수 있다.

```javascript
const ella = {
  name: 'Ella',
  age: 20,
  home: { address: 'Seoul' }
};

// Ella 객체를 사용하여 Updated 객체 생성 (얕은 복사)
const updated = {
  ...ella,
  job: 'FE developer'
};

// 변경 전
console.log(ella.home); // Seoul
console.log(updated.home); // Seoul

// 변경 후: Updated 객체의 home 속성 변경
updated.home.address = 'Busan';

console.log(ella.home); // Busan
console.log(updated.home); // Busan
```

<br/>

## 2. 깊은 복사

### (1) 설명

따라서 객체 내부의 객체와 같은 중첩된 구조를 복사할 때는 깊은 복사(deep copy)를 고려해야 한다. 깊은 복사는 **객체의 모든 수준을 새로운 메모리에 복사**하여, **원본 객체와 완전 독립된 복사본을 생성**한다. 이를 통해 중첩된 객체들이 서로 영향을 주지 않도록 할 수 있다.

### (2) 깊은 복사 방법

#### a. JSON.stringify

깊은 복사를 하는 방법으로는 JSON.stringify()를 사용해 `ella` 객체를 JSON 문자열로 변환하고, JSON.parse()로 문자열을 다시 새로운 객체로 변환한다. 이렇게 하면 `updated`는 `ella`의 깊은 복사본이 되며, 서로 완전히 독립적인 상태가 된다. 하지만 객체 내 함수나 순환 참조, 특별한 객체 (날짜, 정규 표현식 등)는 올바르게 복사되지 않을 수 있다.

```javascript
const ella = {
  name: 'Ella',
  age: 20,
  home: { address: 'Seoul' }
};

// Ella 객체를 깊은 복사하여 Updated 객체 생성
const updated = JSON.parse(JSON.stringify(ella));
updated.job = 'FE developer';
updated.home.address = 'Busan';

console.log(ella.home.address); // Seoul: 원본 데이터 변하지 않음
console.log(updated.home.address); // Busan
```

#### b. 재귀 함수 사용

재귀 함수를 사용하여 객체의 모든 수준을 탐색하고 새로운 객체에 복사할 수 있으며 객체 내부의 중첩된 객체, 배열 등도 처리할 수 있다.

아래의 `deepCopy` 함수는 중첩된 객체의 각 수준에 대해 자기 자신을 반복적으로 호출하며, 각 수준에서 복사본을 생성한다. 이 과정은 객체의 모든 중첩 수준이 처리될 때까지 계속되며 그 결과, 전체 객체 구조가 완전히 복사된다.

```javascript
const ella = {
  name: 'Ella',
  age: 20,
  home: { address: 'Seoul' }
};

function deepCopy(obj) {
  // 재귀 종료 조건을 꼭 작성해준다
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }

  let temp = Array.isArray(obj) ? [] : {};

  for (let key in obj) {
    temp[key] = deepCopy(obj[key]); // deepCopy가 자기 자신을 호출, 호출은 객체의 중첩된 속성에 대해 수행되며 각 중첩된 객체 또는 배열도 복사
  }

  return temp;
}

const updated = deepCopy(ella);
updated.home.address = 'Busan';

console.log(ella.home.address); // Seoul: 원본 데이터 변하지 않음
console.log(updated.home.address); // Busan
```
#### c. Object.assign() 또는 Spread 연산자를 이용한 중첩된 객체 처리

[`Object.assign()`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) 또는 Spread 연산자(`...`)는 얕은 복사를 한다. 하지만 중첩된 객체에 대해서는 원본 객체가 바뀔 수 있기에 추가로 재귀를 이용해 깊은 복사를 구현할 수 있다.

```javascript
// 1. 원본 데이터가 변하는 경우: Object.assign()만 사용
const ella = {
  name: 'Ella',
  age: 20,
  home: { address: 'Seoul' }
};

// Object.assign을 사용하여 얕은 복사
const copied = Object.assign({}, ella);

// 복사된 객체의 중첩된 속성을 변경
copied.home.address = 'Busan';

console.log(ella.home.address); // Busan: 원본 데이터가 변함
console.log(copied.home.address); // Busan

```

```javascript
// 2. 원본 데이터가 변하지 않는 경우: Object.assign() + 재귀 호출
function deepCopy(obj) {
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }

  let copy = Array.isArray(obj) ? [] : {};

  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      copy[key] = (typeof obj[key] === 'object' && obj[key] !== null) ? deepCopy(obj[key]) : obj[key]; // deepCopy 재귀 호출
    }
  }

  return copy;
}

const ella = {
  name: 'Ella',
  age: 20,
  home: { address: 'Seoul' }
};

const updated = deepCopy(ella);
updated.home.address = 'Busan';

console.log(ella.home.address); // Seoul: 원본 객체가 바뀌지 않음
console.log(updated.home.address); // Busan
```

#### d. 서드 파티 라이브러리 사용

[Lodash](https://despiteallthat.tistory.com/167)라는 라이브러리의 `_.cloneDeep()` 같은 함수를 사용할 수도 있다. JavaScript에서 배열 안의 객체들의 값을 핸들링 할 때 유용하다.

```javascript
import _ from 'lodash';

const ella = {
  name: 'Ella',
  age: 20,
  home: { address: 'Seoul' }
};

const updated = _.cloneDeep(ella);
updated.home.address = 'Busan';

console.log(ella.home.address); // Seoul
console.log(updated.home.address); // Busan
```
