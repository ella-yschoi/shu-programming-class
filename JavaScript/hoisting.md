# 📒 Hoisting

hoist의 사전적 의미는 '끌어 올리기' 라는 뜻입니다. 변수나 함수의 선언 코드가 호출 코드보다 아랫쪽에 있음에도 불구하고 에러가 발생하지 않고, 마치 선언 코드가 끌어올려져 호출 코드보다 더 위에 선언된 것과 같이 동작하는 특성을 hoisting(호이스팅) 이라고 합니다.

<br/>

## 0. 목차

<!-- no toc -->
1. [var, let, const](#1-var-let-const)
2. [함수 호이스팅과 변수 호이스팅](#2-함수-호이스팅과-변수-호이스팅)
3. [TDZ](#3-tdz)
4. [호이스팅의 역할](#4-호이스팅의-역할)
5. [참고 자료](#5-참고-자료)

<br/>

## 1. var, let, const

var는 세 가지 문제를 가지고 있었습니다. (1) 값을 선언도 하기 전에 할당을 할 수 있고, (2) 전역변수와 지역변수의 개념이 확실하지 않으며, (3) 같은 이름의 변수가 두 개 이상이 될 수 있습니다. 이로 인해 let이나 const를 사용하게 되었는데, 사실 let과 const도 호이스팅이 일어나기는 일어납니다. 다만 차이점이 있습니다.

let과 const에서도 호이스팅이 되어 참조를 할 수 있게 되나, 이때는 선언만 되고 초기화가 되지 않아서 에러가 납니다. 즉, 선언한 변수가 호이스팅이 일어나긴 했지만, let과 cost는 선언과 초기화가 **동시에 일어나지 않았기 때문에** 에러가 발생한 것입니다.

정리하자면, var는 선언과 초기화가 동시에 일어나고 이후에 할당되며, let과 const는 선언과 초기화 사이에 TDZ가 막고 있고, 할당이 모두 동시에 일어나지 않기에 고맙게도 에러가 나야 하는 때에 에러가 잘 날 수 있습니다.

```
var: 선언 및 초기화 → 할당
let, const: 선언 → TDZ → 초기화 → 할당
```

<br/>

## 2. 함수 호이스팅과 변수 호이스팅

함수 호이스팅과 변수 호이스팅의 주요 차이는 호이스팅되는 내용과 스코프에 있습니다. 함수 호이스팅은 **전체 함수**를 스코프의 최상단으로 옮기지만, 변수 호이스팅은 **선언만**을 최상단으로 옮깁니다. 또한 `let`과 `const`는 변수 호이스팅에서 특별한 행동을 보여, 초기화 전에 접근할 수 없는 특징을 가집니다.

### (1) 함수 호이스팅 (Function Hoisting)

함수 선언을 코드의 맨 위로 끌어올리는 것처럼 동작하여, **함수를 선언하기 전에도 호출**할 수 있게 합니다. 이때, **함수 전체**가 호이스팅 됩니다. 이는 함수의 선언 전에도 해당 함수를 호출할 수 있다는 것을 의미합니다.

더불어, 함수 호이스팅은 함수가 선언된 스코프의 최상단으로 이동합니다. 함수 선언은 블록 스코프가 아닌 함수 스코프 또는 전역 스코프에 적용됩니다. 그리고 아래와 같이 함수 선언식에만 적용되며, 함수 표현식에는 적용되지 않습니다.

```javascript
// 함수 선언식
hello();

function hello() {
  console.log("Hello, world!"); // Hello, world!
}
```

```javascript
// 함수 표현식
hello();

let hello = function() {
  console.log( "Hello" ); // ReferenceError
};
```

호이스팅이 함수 선언식과 함수 표현식에서 다르게 작동하는 이유는 두 가지 선언 방식의 본질적 차이 때문입니다.

#### 함수 선언식

함수 선언식은 함수 전체를 호이스팅합니다. 이는 JavaScript 엔진이 코드를 실행하기 전에 **함수 선언을 먼저 읽고 메모리에 저장하기 때문**입니다. 따라서, 함수 선언식은 코드의 **어느 곳에서든 호출이 가능**합니다.

#### 함수 표현식

함수 표현식은 변수에 함수를 할당하는 형태입니다. 여기서 변수 호이스팅은 발생하지만, **함수 자체의 호이스팅은 발생하지 않습니다**. 즉, 변수가 호이스팅되어 undefined로 초기화되지만, **함수의 할당은 실제 코드의 위치에서 이루어집니다**. 따라서 함수 표현식은 선언된 후에만 사용할 수 있습니다.

### (2) 변수 호이스팅 (Variable Hoisting)

변수 호이스팅이란, 변수의 선언 위치와 상관 없이 코드 내 어느 곳에서든 호출이 가능하지만, 초기화는 `undefined` 입니다.

`var`로 선언된 변수의 경우, 선언은 코드의 맨 위로 호이스팅되지만 초기화는 호이스팅되지 않습니다. 따라서 선언 전에 변수에 접근하면 `undefined` 값을 얻게 됩니다.

```javascript
console.log(x); // undefined
var x = 5;
console.log(x); // 5

console.log(y); // ReferenceError: y is not defined
let y = 10;
```

반면, `let`과 `const`로 선언된 변수도 호이스팅되지만, 초기화 전에 접근하려고 하면 ReferenceError가 발생합니다. 이들은 '임시적 사각지대(Temporal Dead Zone)'에 빠지기 때문입니다.

또한, `var`로 선언된 변수는 함수 스코프 또는 전역 스코프에 호이스팅됩니다. 반면, `let`과 `const`는 블록 스코프에 호이스팅됩니다.

<br/>

## 3. TDZ

### (1) TDZ(Temporal Dead Zone)

TDZ(Temporal Dead Zone)는 '임시적 사각지대'라고 번역될 수 있으며, JavaScript에서 `let`과 `const`로 선언된 변수들이 작동하는 특별한 영역을 의미합니다. TDZ는 let과 const로 선언된 변수에 대해, 그 변수가 선언된 이후부터 초기화되기 전까지의 구간을 말합니다. 이 구간에서 해당 변수에 접근하려고 하면 참조 에러(ReferenceError)가 발생합니다.

### (2) TDZ의 존재 목적

변수가 선언되고 해당 스코프에 진입할 때부터 초기화되기 전까지의 구간동안 변수는 존재하지만 접근할 수 없는 상태가 됩니다. **TDZ의 주요 목적은 변수를 사용하기 전에 선언을 강제하여, 코드의 안정성과 가독성을 높이는 것**입니다.

### (3) let과 TDZ의 관계

`let`으로 선언된 변수는 호이스팅이 발생하지만, TDZ에 의해 초기화 전까지 접근할 수 없는 상태가 됩니다. 때문에 변수가 선언된 코드 라인에 도달할 때까지 해당 변수에 접근하려고 하면 참조 에러가 발생합니다. `let`으로 선언된 변수는 선언과 동시에 초기화되며, 이후에는 정상적으로 접근할 수 있습니다. 따라서 TDZ는 `let`을 사용하여 변수를 미리 사용하는 것을 방지하여 코드의 실수를 줄이고 안정성을 높이는 역할을 합니다.

### (4) 요약

TDZ는 `let`과 `const`로 선언된 변수에 적용되는 JavaScript의 중요한 메커니즘이며, 변수를 안전하고 예측 가능하게 사용할 수 있도록 도와줍니다. 반면, `var`로 선언된 변수는 TDZ의 영향을 받지 않으며, 선언 전에 접근할 경우 `undefined` 값을 반환합니다.

<br/>

## 4. 호이스팅의 역할

일반적으로 함수와 변수가 정의된 이후에만 사용될 수 있지만, 호이스팅은 함수의 선언을 스코프의 상단으로 끌어올려 함수가 선언되기 전에도 호출될 수 있게 합니다. 이는 특정 상황에서 코드 구조와 읽기의 용이성 측면에서 유리할 수 있습니다.

예를 들어, 아래의 예시 코드에서 `processData` 함수는 호출 위치보다 아래에 선언되었지만, 호이스팅으로 인해 문제없이 동작합니다.

### (1) 함수 선언과 로직 분리

```javascript
// 함수 호출
processData();

// 나머지 코드
// ...

// 함수 선언
function processData() {
  // 함수 로직
}
```

호이스팅 덕분에 함수를 파일이나 코드의 하단에 선언하고, 이 함수들을 나중에 상단에서 호출하는 로직을 구성할 수 있습니다. 이 방식은 코드의 가독성과 구조적 명확성을 향상시킬 수 있습니다.

호이스팅은 JavaScript에서 함수 선언을 코드의 상단으로 끌어올리는 것처럼 동작하기에, 함수를 실제로 코드의 하단에 작성하더라도, 호이스팅으로 인해 코드의 어느 곳에서든 함수를 호출할 수 있게 됩니다. 이는 함수의 로직을 파일의 하단에 유지하면서도, 필요한 시점에 함수를 자유롭게 호출할 수 있게 해줍니다.

### (2) 재귀 함수

재귀 함수에서는 함수가 자기 자신을 호출합니다. 호이스팅이 없다면, 함수는 자신이 완전히 정의되기 전까지 자기 자신을 호출할 수 없을 것입니다. 다시 말하자면, 재귀 함수에서는 함수가 실행 중에 자기 자신을 다시 호출하는데, 이때 함수의 선언이 그 함수의 호출보다 코드 상에서 아래에 위치할 경우, 호이스팅이 없다면 자기 자신을 참조할 수 없어 재귀 호출이 불가능할 것입니다.

아래의 예시 코드에서 `factorial` 함수는 자기 자신을 호출하는 재귀 함수이며, 호이스팅이 이를 가능하게 합니다.

```javascript
function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}

console.log(factorial(10))
```

### (3) 조건적 함수 선언

특정 조건에 따라 다른 함수를 선언하고 싶을 때 호이스팅을 활용할 수 있습니다. 이 경우, 조건문 안에서 함수를 선언하고, 코드의 다른 부분에서 이 함수를 자유롭게 호출할 수 있습니다.

```javascript
if (condition) {
  function customFunction() {
    // 조건에 따른 함수 로직
  }
}

customFunction();
```

위의 예시 코드에서 `customFunction`은 조건문 내부에서 선언되지만, 호이스팅 덕분에 외부에서 호출할 수 있습니다.

위와 같은 상황들에서 호이스팅은 코드의 구조를 개선하고, 다양한 시나리오에서 함수를 더 자유롭게 사용할 수 있게 합니다. 하지만 호이스팅의 복잡성과 예기치 않은 동작을 피하기 위해 코드를 명확하고 읽기 쉽게 작성하는 것이 좋습니다.

<br/>

## 5. 참고 자료

- [MDN - 호이스팅](https://developer.mozilla.org/ko/docs/Glossary/Hoisting)
- [JavaScript의 hoisting (호이스팅) 이란? - let과 var의 차이, let과 const 호이스팅](https://dev-ellachoi.tistory.com/1)
